#원형으로 배열된 n명의 색 중 인접하지 않은 k개의 색을 고르는 방법의 수

#일렬로 배열한 경우에서, 원형으로 앉았을 때 불가능한 경우를 제외

#일렬로 배열한 경우는 x1+x2+...+xk+1 = n-k, x1,xk+1 >= 0, x2,x3,..,xk >= 1인 정수해의 개수
#k+1Hn-2k+1 = n-k+1Ck
#여기서 원형으로 앉았을 때 불가능한 경우는 양 끝 x1 = 0, xk+1 = 0이면 b1,bk이 서로 붙어버리므로 불가능
#x2+...+xk = n-k인 1이상의 정수해의 개수
#k-1Hn-2k+1 = n-k-1Ck-2
n = int(input())

k = int(input())

f = [0]*(n+1)

f[0] = 1

mod = 10**9+3

for i in range(1,n+1):
    
    f[i] = f[i-1] * i

v1 = f[n-k+1]//(f[k]*f[n-k+1-k])
v2 = f[n-k-1]//(f[k-2]*f[n-k-k+1])

print((v1 - v2) % mod)


#원형으로 배열된 n개의 색에서 서로 인접하지 않은 k개의 색을 고르는 방법

#b1을 고정하고 x1+x2+...+xk = n-k, xi >= 1인 정수해의 개수 kHn-2k = n-k-1Ck-1
#b1을 고정하는 방법의 수 nC1 = n
#n*n-k-1Ck-1가지에서 원형으로 배열된 b1,b2,..,bk의 경우 첫번째 사람이 k자리에 앉은 경우가 모두 같으므로
#k로 나눠줘야함
n = int(input())

k = int(input())

f = [0]*(n+1)

f[0] = 1

mod = 10**9+3

for i in range(1,n+1):
    
    f[i] = f[i-1] * i

v = f[n-k-1]//(f[k-1]*f[n-k-k])

print((v*n//k) % mod)